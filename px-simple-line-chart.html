<link rel="import" href="../polymer/polymer.html"/>

<!--
Simple line chart component

##### Usage

    <px-simple-line-chart data="{{data}}"></px-simple-line-chart>

@element px-simple-line-chart
@blurb Simple line chart component
@homepage index.html
@demo demo.html
-->
<dom-module id="px-simple-line-chart">
    <script type="text/javascript" src="../d3/d3.js"></script>
    <link rel="import" type="css" href="css/px-simple-line-chart.css" />
    <template>
        <svg class="px-simple-line-chart-svg"></svg>
    </template>
</dom-module>
<script>
    Polymer({

        is: 'px-simple-line-chart',

        /**
         * Properties block, expose attribute values to the DOM via 'reflect'
         *
         * @property properties
         * @type Object
         */
        properties: {
            /**
            * lineData
            *
            * Format: [ [7, 11], [10, 4], [15, 10] ... ]
            */
            lineData: {
                type: Object,
                observer: 'drawChartDebounced'
            },
            /**
            * threshold
            *
            * Format: String
            */
            threshold: {
                type: String,
                observer: 'drawChartDebounced',
                value: ''
            },
            /**
            * thresholdLabel
            *
            * Format: String
            */
            thresholdLabel: {
                type: String,
                observer: 'drawChartDebounced',
                value: ''
            },
            /**
            * max
            *
            * Format: String
            */
            max: {
                type: String,
                observer: 'drawChartDebounced',
                value: null
            },
            /**
            * min
            *
            * Format: String
            */
            min: {
                type: String,
                observer: 'drawChartDebounced',
                value: null
            },
            /**
            * max
            *
            * Format: String
            */
            maxLabel: {
                type: String,
                observer: 'drawChartDebounced',
                value: ''
            },
            /**
            * min
            *
            * Format: String
            */
            minLabel: {
                type: String,
                observer: 'drawChartDebounced',
                value: ''
            },
            /**
            * width
            *
            * Format: Number
            */
            width: {
                type: Number,
                observer: 'drawChartDebounced',
                value: 283
            },
            /**
            * height
            *
            * Format: Number
            */
            height: {
                type: Number,
                observer: 'drawChartDebounced',
                value: 150
            },
            /**
            * columns
            *
            * Format: Number
            */
            columns: {
                type: Number,
                observer: 'drawChartDebounced',
                value: 7
            },
            /**
            * rows
            *
            * Format: Number
            */
            rows: {
                type: Number,
                observer: 'drawChartDebounced',
                value: 7
            },
            /**
            * High
            *
            * Format: Number
            */
            padding: {
                type: Boolean,
                observer: 'drawChartDebounced',
                value: true
            }
        },

        setSizes: function() {
            // calculate target column width including extra column for axis bar
            this.barWidth = 0;
            this.fullWidth = this.width;
            if(this.threshold || this.min || this.max) {
                this.barWidth = parseInt(this.getAxisLabelWidth() + 14);
            };
            this.chartWidth = this.width - this.barWidth;
            this.columnWidth = parseInt(this.chartWidth / ( this.columns ));
            if(this.barWidth) {
                this.barWidth += this.chartWidth % this.columns;
            } else {
                this.fullWidth = this.fullWidth -
                    (this.chartWidth % this.columns);
            }
            this.chartHeight = this.height;
            this.rowHeight = parseInt(this.height / this.rows);
            this.chartHeight = this.chartHeight - (this.height % this.rows);
        },

        extentWithPadding: function(data) {
            var extent = d3.extent(data, function(d) { return d[1]; });
            extent[0] = this.min ? this.min : extent[0];
            extent[1] = this.max ? this.max : extent[1];
            if(this.padding) {
                var diff = Math.abs(extent[0] - extent[1]);
                var pad = diff * 0.05; // pad vertical by 5%
                extent[0] -= pad;
                extent[1] += pad;
            }
            return extent;

        },

        drawChartDebounced: function(data, previous) {
            this.debounce('drawChart', function() {
                this.drawChart();
            }, 200);
        },

        attachSVG: function() {
            // select the svg element
            this.svg = d3.select(this.$$(".px-simple-line-chart-svg"))
                .attr("width", this.width)
                .attr("height", this.height);
            // Remove previous child elements
            this.svg.text("");
        },

        drawChartLine: function() {
            this.svg.append("path")
                .datum(this.lineData)
                .attr("class", "chartLine")
                .attr("d", this.chartLineFunction);
            this.addStyleScope();
        },

        setScales: function() {
            this.xScale = d3.scale.linear()
                .range([this.barWidth+0.5, this.fullWidth-0.5])
                .domain(d3.extent(this.lineData, function(d) { return d[0]; }));
            this.yScale = d3.scale.linear()
                .range([this.chartHeight, 0])
                .domain(this.extentWithPadding(this.lineData));
        },

        typeofToString: function(a) {
            return (typeof a).toString().toLowerCase();
        },

        reconcileMinOrMax: function(value, type) {
            // value may be: number, number as string, 'auto', or empty string
            // type is 'min' or 'max'
            this.autoMinMax = false;
            if(this.typeofToString(value) === 'string') {
                if(value.length === 0) {
                    this.autoMinMax = true; // empty string means 'auto' by default
                } else if(value === 'auto') {
                    this.autoMinMax = true;
                };
            };
            if(this.autoMinMax) {
                // automatic calculation
                var valueFunction = (type === 'max') ? d3.max : d3.min;
                return valueFunction(
                    this.lineData, function(d) { return d[1]; }
                );
            } else if(parseFloat(value)){
                // number as string
                return parseFloat(value);
            } else {
                // do not show
                return ''; // empty string evaluates to false
            };
        },

        reconcileThreshold: function(value) {
            if(parseFloat(value)) {
                return parseFloat(value);
            } else {
                return ''; // empty string evaluates to false
            }
        },

        drawChart: function() {
            if(this.lineData) {
                this.min = this.reconcileMinOrMax(this.min, 'min');
                this.max = this.reconcileMinOrMax(this.max, 'max');
                this.threshold = this.reconcileThreshold(this.threshold);
                this.minLabel = this.minLabel !== '' ? this.minLabel : this.min.toString();
                this.maxLabel = this.maxLabel !== '' ? this.maxLabel : this.max.toString();
                this.thresholdLabel = this.thresholdLabel === '' ? this.threshold.toString() : this.thresholdLabel;
console.log('t-label: '+this.thresholdLabel)
                this.requireAxisBar = (this.threshold || this.min || this.max) ? true : false;
                this.attachSVG();
                this.setSizes();
                this.setScales();
                this.setChartLineFunction();
                this.setLinearLineFunction();
                this.addGridLines();
                if(this.requireAxisBar) {
                    this.addAxisBar();
                    this.drawAxisLabels();
                    if(this.threshold) {
                        this.drawThresholdLine();
                    };
                };

                this.drawChartLine();
                this.addChartBorders();
                this.addStyleScope();
            } else {
                var that = this;
                var timeout = setTimeout(function(){
                    that.drawChart();
                }, 100);
            }
        },

        // Fired on attached event
        attached: function() {
            this.drawChartDebounced();
        },

        addStyleScope: function() {
            // polymer does not apply the local style-scope classes to svg child nodes
            // so we need to add .px-simple-line-chart-svg here
            if(this.svg[0] && this.svg[0][0]) {
                d3.selectAll(this.svg[0][0].childNodes)
                    .classed("px-simple-line-chart", true);
            }
        },

        addAxisBar: function() {
            this.svg.append("rect")
                .attr("class", "axisBar")
                .attr("x", 1)
                .attr("y", 0)
                .attr("width", this.barWidth - 2)
                .attr("height", this.chartHeight);
        },

        drawAxisLabels: function() {
            if(this.thresholdLabel) {
                this.thresholdLabelSVG = this.svg.append("text")
                    .attr("class", "axisLabel")
                    .attr("text-anchor", "middle")
                    .text(this.thresholdLabel)
                    .attr("x", this.barWidth/2)
                    .attr("y", parseInt(this.yScale(this.threshold)) + 5);
            }
            if(this.min) {
                this.minLabelSVG = this.svg.append("text")
                    .attr("class", "axisLabel")
                    .attr("text-anchor", "middle")
                    .text(this.minLabel.toString())
                    .attr("x", this.barWidth/2)
                    .attr("y", this.chartHeight - 8);
            };
            if(this.max) {
                this.maxLabelSVG = this.svg.append("text")
                    .attr("class", "axisLabel")
                    .attr("text-anchor", "middle")
                    .text(this.maxLabel.toString())
                    .attr("x", this.barWidth/2)
                    .attr("y", 18);
            }
        },

        getAxisLabelWidth: function() {
            var labelStrings = [
                this.thresholdLabel,
                this.minLabel,
                this.maxLabel
            ];
            var longestString = labelStrings.sort(function (a, b) {
                return b.length - a.length;
            })[0];
            this.barLabel = this.svg.append("text")
                .attr("class", "axisLabel")
                .attr("text-anchor", "middle")
                .text(longestString);
            var labelWidth = parseInt(
                this.barLabel.style("width").split('px')[0]
            );
            var barLabel = this.barLabel.remove(); // cleanup, we will redraw it
            return labelWidth;
        },

        setLinearLineFunction: function() {
            this.linearLineFunction = d3.svg.line()
                .x(function(d) { return d.x; })
                .y(function(d) { return d.y; })
                .interpolate("linear");
        },

        setChartLineFunction: function() {
            var that = this;
            this.chartLineFunction = d3.svg.line()
                .x(function(d) { return that.xScale(d[0]); })
                .y(function(d) { return that.yScale(d[1]); });
        },

        addChartBorders: function() {
            // Top line
            this.svg.append("path")
                .attr("class", "chartBorder")
                .attr("d", this.linearLineFunction([
                    { "x": 0, "y": 0.5 },
                    { "x": this.fullWidth, "y": 0.5 }
                ])
            );
            // Bottom line
            this.svg.append("path")
                .attr("class", "chartBorder")
                .attr("d", this.linearLineFunction([
                    { "x": 0, "y": this.chartHeight - 0.5 },
                    { "x": this.fullWidth, "y": this.chartHeight - 0.5 }
                ])
            );
            // Bottom white cover
            this.svg.append("rect")
                .attr("class", "chartBottom")
                .attr("x", 0)
                .attr("y", this.chartHeight + 0.5)
                .attr("fill", "#FFFFFF")
                .attr("width", this.width)
                .attr("height", Math.abs(this.chartHeight - this.height));
        },

        addGridLines: function() {
            // Prepare gridlines matrix
            var gridLines = [];
            // First vertical column line
            gridLines.push([
                {
                    "x": 0.5,
                    "y": 0
                },
                {
                    "x": 0.5,
                    "y": this.chartHeight
                }
            ]);
            // Vertical column lines
            for( i = 0; i <= this.columns; i++) {
                gridLines.push([
                    {
                        "x": (i*this.columnWidth)+this.barWidth-0.5,
                        "y": 0
                    },
                    {
                        "x": (i*this.columnWidth)+this.barWidth-0.5,
                        "y": this.chartHeight
                    }
                ]);
            };
            // Horizontal row lines
            for( i = 0; i <= this.rows -1; i++) {
                gridLines.push([
                    {
                        "x": 0,
                        "y": i*this.rowHeight+0.5
                    },
                    {
                        "x": this.fullWidth,
                        "y": i*this.rowHeight+0.5
                    }
                ]);
            };
            // Append grid lines to svg
            for(i=0;i<gridLines.length;i++) {
                this.svg.append("path")
                    .attr("class", "chartGrid")
                    .attr("d", this.linearLineFunction(gridLines[i]));
            };
        },

        drawThresholdLine: function() {
            if(this.svg) {
                var y = parseInt(this.yScale(this.threshold));
                var path = this.svg.select('.thresholdLine');
                if(path.empty()) {
                    path = this.svg.append("path");
                };
                path.attr("class", "thresholdLine")
                    .attr("d", this.linearLineFunction([
                        {
                            "x": this.barWidth,
                            "y": y + 0.5
                        },
                        {
                            "x": this.fullWidth,
                            "y": y + 0.5
                        }
                    ])
                );
                this.addStyleScope();
            } else {
                var that = this;
                var timeout = setTimeout(function() {
                    that.drawThreshold();
                }, 100);
            }
        }

    });
</script>
